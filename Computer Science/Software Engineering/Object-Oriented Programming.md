## 객체지향 프로그래밍

현실 세계의 사물들을 객체로 보고, 그 사물로부터 필요한 특징(속성, 기능)들을 추출해 field와 method를 정의하고, 하나의 객체에 묶어서 관리하는 것이다. 
이것을 추상화라 한다.

<br>

도서관의 책을 예로 들면, 책의 제목, 저자, 페이지와 같은 속성과 읽기, 예약하기 등의 기능을 '책'이라는 객체에 한번에 묶어서 저장하는 방식이다.

<br>

객체지향으로 구현하게 되면, 객체 간의 독립성이 생기고 중복 코드의 양이 줄어드는 장점이 있다. 객체 단위로 코드가 나눠져 작성되고, 객체 간 독립성으로 유지보수에도 도움이 된다.

독립적으로 만들어진 객체들 간의 의존도를 최대한 낮게 만드는 것이 중요하다. 객체들 간의 의존도가 높아지면 객체 지향으로 설계하는 의미가 없어진다.

<br>

#### 특징

객체지향의 패러다임이 생겨나면서 크게 4가지 특징을 갖추게 되었다.

이 4가지 특성을 잘 이해하고 구현해야 객체를 통한 효율적인 구현이 가능해진다.

<br>

1. ##### 추상화(Abstraction)

   > 필요로 하는 속성이나 기능을 추출하는 작업

   즉, 세부적인 사물들의 공통적인 특징을 파악한 후 하나의 집합으로 만들어내는 것이 추상화다.

   ```
   ex. 자동차, 오토바이는 모두 '탈것(Vehicle)' 이며,
   모델, 제조사 등의 속성과
   시동을 걸고 전진/후진을 할 수 있다는 기능의 공통점이 있다.
   
   Vehicle이라는 추상화 집합을 만들어두고, Vehicle이 가진 공통적인 특징들을 만들어 활용한다.
   ```

   ***'왜 필요하죠?'***

   예를 들면, 다른 Vehicle이 추가될 수도 있다. 이때 추상화로 구현해두면 다른 곳의 코드는 수정할 필요 없이 추가로 만들 부분만 새로 생성해주면 된다.
   <br>

2. ##### 캡슐화(Encapsulation)

   >  클래스 안에 서로 연관있는 속성과 기능들을 하나의 캡슐(capsule)로 만들어 데이터를 외부로부터 보호하는 것
   
   - 데이터 보호 : 외부로부터 클래스에 정의된 속성과 기능들을 보호
   - 데이터 은닉 : 내부의 동작을 감추고 외부에는 필요한 부분만 노출

   -> 객체 고유의 독립성과 책임 영역을 안전하게 지키고자 하는 목적.

   <br>

   java 접근 제어자
   - private : 동일 클래스
   - default : 동일 패키지
   - protected : 하위 클래스
   - public : 모든 클래스

   getter, setter

   ex.
   ```java
   
   public class Driver {
     private Car car;
     ...
     public void drive() {
       car.start();
       car.moveForward();
       ...
     }
   }
   
   ```
   
   ```java
   
   public class Car {
     public void drive() {
       start();
       moveForward();
       ...
     }
   }
   
   public class Driver {
     private Car car;
     ...
     public void drive() {
       car.drive();
     }
   }


   ```

   ->  Car 클래스와 관련된 기능들은 온전히 Car 에서만 관리되도록 하였고, 불필요한 내부 동작의 노출을 최소화하였다. 이제 Driver 클래스의 입장에서는 더 이상 Car 클래스의 내부 로직을 알지 못하고, 알 필요도 없어졌다.

   <br>

3. ##### 상속

   > 여러 (하위 클래스의) 객체들이 지닌 공통된 field, method를 추출(추상화)하여 상위 클래스를 정의하는 것.

   일반화(상속)은 또 다른 캡슐화다.

   **하위 클래스를 외부로부터 은닉하는 캡슐화의 일종**이라고 할 수 있다.

   <br>

   Vehicle을 통해 추상화를 설명했었다. 여기에 추가로 Driver 클래스가 있다고 생각해보자. 이때, Vehicle의 하위 클래스는 캡슐화를 통해 은닉해둔 상태다.

   Driver 클래스의 관점으로는, 구체적인 자동차의 종류가 숨겨져 있는 상태다. 

   새로운 Vehicle들이 추가된다고 해도, Driver 클래스는 영향을 받지 않는 것이 중요하다. 그러므로 캡슐화를 통해 Driver 클래스(외부) 입장에서는 확인할 수 없도록(은닉) 구현하는 것이다.

   낮은 결합도를 유지할 수 있도록 설계하는 것 (= 객체가 내부적으로 기능을 어떻게 구현하는지 감추는 것)

   <br>

   ***상속은 언제 사용?***

   - IS-A 관계가 성립할 때
   - 재사용 관점이 아닌, 기능의 확장 관점일 때

   <br>

4. ##### 다형성(Polymorphism)

   > 객체의 속성, 기능이 여러 가지 형태를 가질 수 있는 성질
   >
   > 상위 클래스의 method를 하위 클래스에서 역할에 맞게 overriding해서 이루어진다.

   객체 지향의 핵심과도 같은 부분이다.

   <br>

   다형성을 사용하면, 상위 클래스 타입의 참조변수로 하위 클래스의 객체를 참조할 수 있다. 이를 통해 현재 어떤 클래스의 객체가 참조되는지 상관없이 상위 클래스의 method를 호출하면 된다.

   -> 새로운 하위 클래스가 추가되어도 다른 클래스에 영향이 없다.

   <br>

   ex.
   
   ```java
   
   public class Driver {
     void drive(Car car) {
       car.moveForward();
     }
   
     void drive(Motorbike motorbike) {
       motorbike.moveForward();
     }
   
     ...
   }

   ```
   Driver 클래스는 Car, Motorbike 클래스의 method를 호출하고 있다.
   
   -> Driver 클래스는 Car, Motorbike 클래스에 의존한다. (Driver -> Car, Motorbike)
   
   -> 결합도 (coupling)가 높다.
   
   -> 새로운 탈것이 추가된다면? (Bus, Train, ...) / 기존 탈것의 이름을 변경해야 한다면? (Motorbike -> Motorcycle)
   
   ```java
   public interface Vehicle { // 역할
     void moveForward();
   }
   
   public class Car {
     void moveForward() { // 구현
       ...
     }
   }
   
   public class Driver {
     void drive(Vehicle vehicle) {
       vehicle.moveForward();
     }
   }
   
   ```
   (Driver -> Vehicle (Car, Motorbike))
   
   <br>

#### 객체 지향 설계 원칙

SOLID라고 부르는 5가지 설계 원칙이 존재한다.

1. ##### SRP(Single Responsibility) - 단일 책임 원칙

   클래스는 단 한 개의 책임을 가져야 한다.

   클래스를 변경하는 이유는 단 한 개여야 한다.

   이를 지키지 않으면, 한 책임의 변경에 의해 다른 책임과 관련된 코드에 영향이 갈 수 있다.

   <br>

2. ##### OCP(Open-Closed) - 개방-폐쇄 원칙

   확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 한다.

   기능을 변경하거나 확장할 수 있으면서, 그 기능을 사용하는 코드는 수정하지 않는다.

   이를 지키지 않으면, instanceof와 같은 연산자를 사용하거나 다운 캐스팅이 일어난다.

   <br>

3. ##### LSP(Liskov Substitution) - 리스코프 치환 원칙

   상위 타입의 객체를 하위 타입의 객체로 치환해도, 상위 타입을 사용하는 프로그램은 정상적으로 동작해야 한다.

   상속 관계가 아닌 클래스들을 상속 관계로 설정하면, 이 원칙이 위배된다.

   <br>

4. ##### ISP(Interface Segregation) - 인터페이스 분리 원칙

   인터페이스는 그 인터페이스를 사용하는 클라이언트를 기준으로 분리해야 한다.

   각 클라이언트가 필요로 하는 인터페이스들을 분리함으로써, 각 클라이언트가 사용하지 않는 인터페이스에 변경이 발생하더라도 영향을 받지 않도록 만들어야 한다.

   <br>

5. ##### DIP(Dependency Inversion) - 의존 역전 원칙

   고수준 모듈은 저수준 모듈의 구현에 의존해서는 안된다.

   저수준 모듈이 고수준 모듈에서 정의한 추상 타입에 의존해야 한다.

   즉, 저수준 모듈이 변경돼도 고수준 모듈은 변경할 필요가 없는 것이다.

