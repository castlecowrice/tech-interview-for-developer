## 해시(Hash)

데이터를 효율적으로 관리하기 위해, 임의의 길이 데이터를 고정된 길이의 데이터로 매핑하는 것

해시 함수를 구현하여 데이터 값을 해시 값으로 매핑한다.

<br>

```
Lee → 해싱함수 → 5
Kim → 해싱함수 → 3
Park → 해싱함수 → 2
...
Chun → 해싱함수 → 5 // Lee와 해싱값 충돌
```

결국 데이터가 많아지면, 다른 데이터가 같은 해시 값으로 충돌나는 현상이 발생함 **'collision' 현상**

**_그래도 해시 테이블을 쓰는 이유는?_**

> 적은 자원으로 많은 데이터를 효율적으로 관리하기 위해
>
> 하드디스크나, 클라우드에 존재하는 무한한 데이터들을 유한한 개수의 해시값으로 매핑하면 작은 메모리로도 프로세스 관리가 가능해짐!

- 언제나 동일한 해시값 리턴, index를 알면 빠른 데이터 검색이 가능해짐
- 해시테이블의 시간복잡도 O(1) - (이진탐색트리는 O(logN))

<br>

## 충돌 문제 해결

1. **체이닝** : 연결리스트로 노드를 계속 추가해나가는 방식
   (제한 없이 계속 연결 가능, but 메모리 문제)

2. **Open Addressing** : 해시 함수로 얻은 주소가 아닌 다른 주소에 데이터를 저장할 수 있도록 허용 (해당 키 값에 저장되어있으면 다음 주소에 저장)

   a. **선형 조사법(linear probing)** : 정해진 고정 폭으로 옮겨 해시값의 중복을 피함
   ```
   예시)
   ht[k], ht[k+1], ht[k+2] ...
   
   ※ 삽입 상황
   충돌이 ht[k]에서 일어났다면, ht[k+1]이 비어있는지 조사함. 차있으면 ht[k+2] 조사 ...
   테이블 끝까지 도달하면 다시 처음으로 돌아옴. 시작 위치로 돌아온 경우는 테이블이 모두 가득 찬 경우임
   
   ※ 검색 상황
   ht[k]에 있는 키가 다른 값이면, ht[k+1]에 같은 키가 있는지 조사함. 
   비어있는 공간이 나오거나, 검색을 시작한 위치로 돌아오면 찾는 키가 없는 경우
   ```
   b. **이차 조사법(quadratic probing)** : 정해진 고정 폭을 제곱수로 옮겨 해시값의 중복을 피함
   선형 조사법에서 발생하는 **군집화 문제를 완화**시켜 줌
   
   군집화: 데이터가 가까운 곳에 뭉쳐 저장되는 현상.
   
   ```
   h(k), h(k)+1, h(k)+4, h(k)+9 ...
   ```
   
   c. **이중 해시법**
   충돌로 인해 비어있는 버킷을 찾을 때 추가적인 해시 함수 h'()를 사용하는 방식
   
   ```
   h'(k) = C - (k mod C)
   
   조사 위치
   h(k), h(k)+h'(k), h(k) + 2h'(k) ...
   ```

**open addressing 데이터 삭제**

- empty : 검색 종료
- active : 값이 들어 있음
- inactive : 값이 들어있다가 삭제됨 -> 계속 검색.

<br>

## 해시 버킷 동적 확장

해시 버킷의 크기가 충분히 크다면 해시 충돌 빈도를 낮출 수 있다

하지만 메모리는 한정된 자원이기 때문에 무작정 큰 공간을 할당해 줄 수 없다

때문에 `load factor`가 일정 수준 이상 이라면 (보편적으로는 0.7 ~ 0.8) 해시 버킷의 크기를 확장하는 동적 확장 방식을 사용한다

- **load factor** : 할당된 키의 개수 / 해시 버킷의 크기

해시 버킷이 동적 확장 될 때 `리해싱` 과정을 거치게 된다

- **리해싱(Rehashing)** : 기존 저장되어 있는 값들을 다시 해싱하여 새로운 키를 부여하는 것을 말한다

<br>

##### 맵(map)과 해시맵(hashMap)의 차이는?

map 컨테이너는 이진탐색트리(BST)를 사용하다가 최근에 레드블랙트리를 사용하는 중

key 값을 이용해 트리를 탐색하는 방식임 → 따라서 데이터 접근, 삽입, 삭제는 O( logN )

반면 해시맵은 해시함수를 활용해 O(1)에 접근 가능

하지만 C++에서는 해시맵을 STL로 지원해주지 않는데, 충돌 해결에 있어서 안정적인 방법이 아니기 때문 (해시 함수는 collision 정책에 따라 성능차이가 큼) 

<br>

참고자료 : [링크](https://ratsgo.github.io/data%20structure&algorithm/2017/10/25/hash/)
