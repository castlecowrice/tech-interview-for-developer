## 객체지향 프로그래밍

현실 세계의 사물들을 객체로 보고, 그 사물로부터 필요한 특징(속성, 기능)들을 추출해 field와 method를 정의하고, 하나의 객체에 묶어서 관리하는 것이다. 
이것을 추상화라 한다.

<br>

도서관의 책을 예로 들면, 책의 제목, 저자, 페이지와 같은 속성과 읽기, 예약하기 등의 기능을 '책'이라는 객체에 한번에 묶어서 저장하는 방식이다.

<br>

#### 객체지향 vs 절차지향

절차지향

- 컴퓨터의 처리구조와 유사해 실행속도가 빠르다.

객체지향

- 상속을 통해 코드의 재사용성을 높이고 중복 코드를 줄일 수 있다.
- 캡슐화를 통해 새로운 기능 추가 or 기존 기능 수정할 때 다른 코드에 영향이 적어 유지보수가 쉽다.

   Why? 변경 가능성이 높은 부분은 구현으로 숨기고, 외부에는 상대적으로 변경이 거의 없는 부분만 공개하여 변경의 영향을 통제

   https://mangkyu.tistory.com/195

<br>

#### 4가지 특징

[링크](https://www.codestates.com/blog/content/%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%ED%8A%B9%EC%A7%95)

<br>

1. ##### 추상화(Abstraction)

   > 세부적인 사물들의 공통적인 속성과 기능을 추출한 후 하나의 집합으로 만들어내는 것

   ```
   ex. 자동차, 오토바이는 모두 '탈것(Vehicle)' 이며,
   모델, 제조사 등의 속성과
   시동을 걸고 전진/후진을 할 수 있다는 기능의 공통점이 있다.
   
   Vehicle이라는 추상화 집합을 만들어두고, Vehicle이 가진 공통적인 특징들을 만들어 활용한다.
   ```

   ***'왜 필요하죠?'***

   예를 들면, 다른 Vehicle이 추가될 수도 있다. 이때 추상화로 구현해두면 다른 곳의 코드는 수정할 필요 없이 추가할 기능만 생성해주면 된다.
   <br>

2. ##### 캡슐화(Encapsulation)

   > 관련 있는 속성과 기능들을 하나의 클래스(캡슐)로 묶고, 외부로부터 동작(구현)을 감추고 필요한 부분만 노출

3. ##### 상속

   > 기존의 클래스를 재활용하여 새로운 클래스를 작성하는 문법
   >
   > 클래스 간 공통된 속성과 기능들을 상위 클래스로 추상화하고, 해당 상위 클래스로부터 확장된 여러 개의 하위 클래스들이 모두 상위 클래스의 속성과 기능들을 재사용 가능.
   >
   > 하위 클래스를 외부로부터 은닉하는 캡슐화의 예라고 할 수 있다.

   <br>

   *상속은 언제 사용?*

   - IS-A 관계가 성립할 때
   - 재사용 관점이 아닌, 기능의 확장 관점일 때

   <br>

4. ##### 다형성(Polymorphism)

   > 객체의 속성, 기능이 여러 가지 형태를 가질 수 있는 성질
   >
   > 상위 클래스의 method를 하위 클래스에서 역할에 맞게 overriding하고, 상위 클래스 타입의 참조변수로 하위 클래스의 객체를 참조하고, 상위 클래스의 method를 호출한다.

   객체 지향의 핵심과도 같은 부분이다.

   <br>

   ex.
   
   ```java
   
   public class Driver {
     void drive(Car car) {
       car.moveForward();
     }
   
     void drive(Motorbike motorbike) {
       motorbike.moveForward();
     }
   
     ...
   }

   ```
   Driver 클래스는 Car, Motorbike 클래스의 method를 호출하고 있다.
   
   -> Driver 클래스는 Car, Motorbike 클래스에 의존한다. (Driver -> Car, Motorbike)
   
   -> 결합도 (coupling)가 높다.
   
   -> 새로운 탈것이 추가된다면? (Bus, Train, ...) / 기존 탈것의 이름을 변경해야 한다면? (Motorbike -> Motorcycle)
   
   ```java
   public interface Vehicle { // 역할
     void moveForward();
   }
   
   public class Car {
     void moveForward() { // 구현
       ...
     }
   }
   
   public class Driver {
     void drive(Vehicle vehicle) {
       vehicle.moveForward();
     }
   }
   
   ```
   (Driver -> Vehicle (Car, Motorbike))

   Vehicle 클래스에 추가로 Driver 클래스가 있다고 생각해보자. 이때, Vehicle의 하위 클래스는 캡슐화를 통해 은닉해둔 상태다.

   Driver 클래스의 관점으로는, 구체적인 자동차의 종류가 숨겨져 있는 상태다. 따라서, 새로운 Vehicle이 추가된다고 해도 Driver 클래스는 영향을 받지 않게 된다.

   <br>

   <br>

#### 객체 지향 설계 원칙

SOLID라고 부르는 5가지 설계 원칙이 존재한다.

[링크](https://inpa.tistory.com/category/%EB%94%94%EC%9E%90%EC%9D%B8%20%ED%8C%A8%ED%84%B4/OOP)

1. ##### SRP(Single Responsibility) - 단일 책임 원칙

   클래스는 단 한 개의 책임을 가져야 한다.

   클래스를 변경하는 이유는 단 한 개여야 한다.

   이를 지키지 않으면, 한 책임의 변경에 의해 다른 책임과 관련된 코드에 영향이 갈 수 있다.

   <br>

2. ##### OCP(Open-Closed) - 개방-폐쇄 원칙

   확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 한다.

   기능을 변경하거나 확장할 수 있으면서, 그 기능을 사용하는 코드는 수정하지 않는다.

   이를 지키지 않으면, instanceof와 같은 연산자를 사용하거나 다운 캐스팅이 일어난다.

   <br>

3. ##### LSP(Liskov Substitution) - 리스코프 치환 원칙

   상위 타입의 객체를 하위 타입의 객체로 치환해도, 상위 타입을 사용하는 프로그램은 정상적으로 동작해야 한다.

   상속 관계가 아닌 클래스들을 상속 관계로 설정하면, 이 원칙이 위배된다.

   <br>

4. ##### ISP(Interface Segregation) - 인터페이스 분리 원칙

   인터페이스는 그 인터페이스를 사용하는 클라이언트를 기준으로 분리해야 한다.

   각 클라이언트가 필요로 하는 인터페이스들을 분리함으로써, 각 클라이언트가 사용하지 않는 인터페이스에 변경이 발생하더라도 영향을 받지 않도록 만들어야 한다.

   <br>

5. ##### DIP(Dependency Inversion) - 의존 역전 원칙

   고수준 모듈은 저수준 모듈의 구현에 의존해서는 안된다.

   저수준 모듈이 고수준 모듈에서 정의한 추상 타입에 의존해야 한다.

   즉, 저수준 모듈이 변경돼도 고수준 모듈은 변경할 필요가 없는 것이다.

